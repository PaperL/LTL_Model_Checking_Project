# Report

> 仇天元, 520030910137

## 1. LTL Formula Parser and Builder

The LTL (Linear Temporal Logic) Formula Parser and Builder is a crucial component of our system, responsible for parsing and constructing LTL formulas. LTL formulas are used to express temporal properties in various domains, such as system verification and synthesis.

### 1.1 AST Tree and Formula Types

The foundation of the LTL Formula Parser and Builder is the Abstract Syntax Tree (AST) tree. At the root of the AST tree is the formula node, which represents the most commonly used type of formula in LTL.

There are three main types of formulas that can be represented in the AST:

1. Basic Formulas: These formulas encompass various elements, including parentheses to group subformulas, atomic propositions representing specific states or events, and constants that can be either true or false.

2. Unary Formulas: Unary formulas involve a single subformula and specific operators. The available unary operators are "not" (negation), "G" (global), "F" (eventually), and "X" (next).

3. Binary Formulas: Binary formulas combine two subformulas using different operators. The supported binary operators include "and," "or," "implicate," and "until."

For more comprehensive details on the syntax and structure of LTL formulas, please refer to the corresponding grammar file (g4 file).

### 1.2 FormulaBuilder and Custom Data Structure

To facilitate the parsing and construction of LTL formulas, I have developed the `ltl.FormulaBuilder` class. This class inherits from the Antlr4 `BaseVisitor`, enabling me to traverse the AST tree generated by the parser and generate our custom data structure.

The custom formula data structure represents the LTL formulas as a tree of FormulaNode objects. The `FormulaNode` serves as the base class, and specific types of nodes are derived from it based on the formula type they represent. This hierarchical structure allows us to organize and manipulate formulas efficiently within our system.

By utilizing the FormulaBuilder and our custom data structure, we can process LTL formulas, extract relevant information, and perform various operations based on the specific requirements of our application.

Overall, the LTL Formula Parser and Data Structure provide a robust foundation for handling LTL formulas within our system, enabling effective analysis and reasoning about temporal properties.

## 2. LTL Formula -> GNBA

The process of converting an LTL (Linear Temporal Logic) formula into a Generalized Nondeterministic Buchi Automaton (GNBA) is a crucial step in the system. This conversion is based on the proof of *Theorem 5.37* presented in the book *Principles of Model Checking* (page 278). The conversion functionality is implemented within the constructor of the `ba.GNBA` class.

By applying the conversion algorithm, I transform the LTL formula into an equivalent GNBA. The GNBA represents the temporal properties expressed by the LTL formula in a form that can be efficiently analyzed and checked against system models.

## 3. GNBA -> NBA

After obtaining the GNBA from the LTL formula, the next step is to construct a Nondeterministic Buchi Automaton (NBA). The construction of the NBA follows the proof of *Theorem 4.56* outlined in *Principles of Model Checking* (page 195).

The construction process is implemented within the constructor of the `NBA` class. Both the `NBA` and `GNBA` classes inherit from the base abstract class `BA`.

The resulting NBA represents the temporal property expressed by the LTL formula in a format suitable for model checking and analysis.

## 4. Cross Product of Transition System and Nondeterministic Buchi Automaton

To perform model checking on a system with respect to an LTL formula, we need to combine the system's transition system and the Nondeterministic Buchi Automaton (NBA) obtained from the LTL formula. This combination is achieved through the cross product operation.

The cross product of the transition system is implemented in the `TS` class, following the definition provided in *Principles of Model Checking* (page 200), specifically *Definition 4.62*.

By creating the cross product of the transition system and the NBA, I obtain a new model that incorporates both the system's behavior and the temporal properties expressed by the LTL formula. This combined model allows us to perform model checking and verify the satisfaction of the desired temporal properties.

## 5. Persistence Checking

Persistence checking is an essential step in model checking, where we examine whether a specific property persists indefinitely within the system's behavior.

The persistence checking functionality is implemented within the `TS` class. It follows the nested depth-first search algorithm described in *Principles of Model Checking* (page 211). By applying this algorithm, we explore the combined model obtained from the cross product operation and determine if the desired property persists throughout the system's execution.

The persistence checking process enables us to identify any violations or confirm the persistence of properties expressed by the LTL formula within the system's behavior, providing valuable insights into the system's correctness and compliance with specified requirements.